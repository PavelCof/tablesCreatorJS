<div class="task-list">
    <div class="task" draggable="true">
      <span class="task-title">Task 1</span>
    </div>
    <div class="task" draggable="true">
      <span class="task-title">Task 2</span>
    </div>
    <div class="task" draggable="true">
      <span class="task-title">Task 3</span>
    </div>
  </div>
  <div class="task-list">
    <div class="task" draggable="true">
      <span class="task-title">Task 4</span>
    </div>
    <div class="task" draggable="true">
      <span class="task-title">Task 5</span>
    </div>
  </div>
  <script>
    const tasks = document.querySelectorAll('.task');
  
    let draggedTask = null;
  
    tasks.forEach(task => {
      task.addEventListener('dragstart', () => {
        draggedTask = task;
        setTimeout(() => {
          task.classList.add('dragging');
        }, 0);
      });
  
      task.addEventListener('dragend', () => {
        draggedTask.classList.remove('dragging');
        draggedTask = null;
      });
    });
  
    const taskLists = document.querySelectorAll('.task-list');
  
    taskLists.forEach(taskList => {
      taskList.addEventListener('dragover', event => {
        event.preventDefault();
        const afterElement = getDragAfterElement(taskList, event.clientY);
        const task = document.querySelector('.dragging');
        if (afterElement == null) {
          taskList.appendChild(task);
        } else {
          taskList.insertBefore(task, afterElement);
        }
      });
    });
  
    function getDragAfterElement(container, y) {
      const taskElements = [...container.querySelectorAll('.task:not(.dragging)')];
      return taskElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }
  </script>
  